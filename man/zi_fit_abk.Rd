% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zero_est_core.R
\name{zi_fit_abk}
\alias{zi_fit_abk}
\title{Fits a Hurdle polynomial with abk parametrization.}
\usage{
zi_fit_abk(
  V,
  Y,
  left,
  right,
  use_C = TRUE,
  tol = 1e-08,
  maxit = 1000,
  runs = 2,
  value_only = TRUE,
  report = 0,
  step_size = 0.1,
  lm_tol = 0.01,
  maxsize = 1e-10,
  method = 5
)
}
\arguments{
\item{V}{A matrix of 0/1s, equal to Y != 0.}

\item{Y}{A data matrix of the same size as \code{V}.}

\item{left}{An integer between 1 and \code{ncol(Y)}. The index of the variable to be fit.}

\item{right}{A vector of integers between 1 and \code{ncol(Y)} different from \code{left}. Indices of the "regressors".}

\item{use_C}{A logical. Function calls \code{zi_fit_C()} if \code{use_C == TRUE}, and otherwise calls \code{zi_fit_R()}.}

\item{tol}{A positive number. If \code{use_C == FALSE} the tolerance passed as the \code{pgtol} argument to \code{stats::optim} (\code{tol} argument of \code{zi_fit_R()}). If \code{use_C == TRUE}, accuracy of the minimization (\code{epsabs} argument of \code{zi_fit_C()}).}

\item{maxit}{An integer, the maximum number of integers, argument to \code{stats::optim}.}

\item{runs}{A positive integer, number of reruns; if larger than \code{1}, \code{stats::optim} will be called multiple times with different initial values, and the fit that maximizes the log likelihood will be used.}

\item{value_only}{If \code{TRUE}, returns the minimized negative log likelihood only.}

\item{report}{An integer indicating verbosity. If \code{use_C == FALSE}, passed as \code{report} argument to \code{zi_fit_R()}, argument to \code{stats::optim}: if set to 1 no output is print during estimation. If \code{use_C == TRUE}, passed as \code{verbosity} argument to \code{zi_fit_C()}, argument to optim() in C code: a positive integer, verbosity level; if set to 0 no output is print during estimation.}

\item{step_size}{A double, the step size of the first trial step. Defaults to 0.1.}

\item{lm_tol}{A double, accuracy of the line minimization.}

\item{maxsize}{A double, the final size of the simplex.}

\item{method}{A positive integer indicating the method to use. 5 is recommended and default.}
}
\value{
If \code{value_only == TRUE}, returns the minimized negative log likelihood only. Otherwise, returns
  \item{nll}{A number, the minimized negative log likelihood.}
  \item{par}{A vector of length \code{4*length(right)+3}, the fitted parameters, in the other of: the intercept for the \code{a} (a scalar), linear coefficients on \code{V[,right]} for \code{a}, linear coefficients on \code{Y[,right]} for \code{a}, the intercept for the \code{b} (a scalar), linear coefficients on \code{V[,right]} for \code{b}, linear coefficients on \code{Y[,right]} for \code{b}.}
  \item{n}{An integer, the sample size.}
  \item{effective_df}{\code{4*length(right)+3}, the effective degree of freedom.}
}
\description{
Fits a Hurdle polynomial with abk parametrization.
}
\details{
If \code{right} is empty, fits an unconditional univariate Hurdle using \code{mle1d_abk()}.
If \code{use_C == TRUE}, calls \code{zi_fit_C()}.
If \code{use_C == FALSE}, calls \code{zi_fit_R()}.
}
\examples{
adj_mat <- matrix(c(1,1,0, 0,1,0, 0,0,0), nrow=3, byrow=TRUE)
dat <- gen_zero_dat(1, "abk", adj_mat, 1000, k_mode=1, min_num=10, gen_uniform_degree=1)
zi_fit_abk(dat$V, dat$Y, 3, 1:2, use_C=FALSE, maxit=1000, runs=2, value_only=TRUE, report=0)
zi_fit_abk(dat$V, dat$Y, 3, 1:2, use_C=TRUE, maxit=1000, runs=2, value_only=TRUE, report=0)
zi_fit_abk(dat$V, dat$Y, 3, 1:2, use_C=FALSE, maxit=1000, runs=2, value_only=FALSE, report=0)
zi_fit_abk(dat$V, dat$Y, 3, 1:2, use_C=TRUE, maxit=1000, runs=2, value_only=FALSE, report=0)
}
