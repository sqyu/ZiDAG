% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stability_function.R
\name{CPSS_path}
\alias{CPSS_path}
\title{Generates a path of estimates of adjacency matrix using results from CPSS_fit().}
\usage{
CPSS_path(freq_B, B = 50, force_acyclic = TRUE)
}
\arguments{
\item{freq_B}{A square matrix returned from \code{CPSS_fit()}, the frequency of each entry inn the adjacency matrix in the estimates using the \code{2*B} sets of subsamples.}

\item{B}{An integer, number of pairs of subsamples to be drawn, should be equal to the \code{B} used when calling \code{CPSS_fit()}. Defaults to \code{50}.}

\item{force_acyclic}{A logical, whether return estimated adj matrices that correspond to acyclic graphs only.}
}
\value{
A list containing \code{"graph"} (a list of adjacency matrices), \code{"freq"} (a vector of numbers in [0,1]), and \code{"actual_fdr"} (a vector of numbers in [0,1]), all of the same length; see Details.
}
\description{
Generates a path of estimates of adjacency matrix given the frequencies of each entry in the estimates using subsamples drawn as complementary pairs.
}
\details{
Assuming \code{fitting_func} takes a list of indices and returns an adjacency matrix, each entry in \code{freq_B <- CPSS_fit(n, fitting_func, B)} returns the number of times that entry equals to \code{1} in the \code{2*B} estimated adjacency matrices.
\code{CPSS_path(freq_B, B)} returns a path of graph estimates by gradually decreasing the frequency threshold.
The path is a list containing \code{"graph"} (a list of adjacency matrices), \code{"freq"} (a vector of numbers in [0,1], the frequency threshold), and \code{"actual_fdr"} (a vector of numbers in [0,1], the actual FDR controlled), each corresponding to a final estimate. For each estimate, entries in \code{freq_B} that have frequency above \code{2*B*freq} are set to 1, and 0 otherwise, while \code{actual_fdr} is calculated as in Shah and Samworth (2012).
For example, if \code{freq_B} is [0 84 10; 0 0 71; 0 12 0] and \code{force_acyclic == TRUE}, the function returns a path with graphs [0 1 0; 0 0 0; 0 0 0] (\code{freq} 0.84), [0 1 0; 0 0 1; 0 0 0] (\code{freq} 0.71), [0 1 0; 0 0 1; 0 1 0] (\code{freq} 0.12), [0 1 1; 0 0 1; 0 1 0] (\code{freq} 0.10).
Fore more details, see Shah and Samworth (2012) and the documentation on \code{CPSS_fit()}.

Note: The user is expected to call \code{CPSS_fit()}, followed by \code{CPSS_path()}, and then followed by \code{CPSS_control()}.
}
\examples{
m <- 3; n <- 100; B <- 10
adj_mat <- ZiDAG::make_dag(m, mode = "chain")
d <- ZiDAG::gen_zero_dat(seed=1, gen_para="pms", adj_mat=adj_mat, n=n, gen_uniform_degree=1)
fitting_func <- function(indices) return (
    ZiDAG::ziGDS(V=d$V[indices,], Y=d$Y[indices,], parametrization="pms", verbose=FALSE,
    control=list("max_uniform_degree"=1L, "tol"=1e-8, "print_best_degree"=FALSE)))
freq_B <- ZiDAG::CPSS_fit(nrow(d$V), fitting_func, B=B, parallel=TRUE, num_cores=2)
cpss_path <- CPSS_path(freq_B, B = B)
}
