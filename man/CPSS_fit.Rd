% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stability_function.R
\name{CPSS_fit}
\alias{CPSS_fit}
\title{Applies a fit function repeatedly to subsamples drawn as complementary pairs (CPSS).}
\usage{
CPSS_fit(n, fitting_func, B = 50, parallel = TRUE, num_cores = NULL)
}
\arguments{
\item{n}{An integer >= 2, the sample size.}

\item{fitting_func}{A function that takes a vector of indices (a subvector of \code{1:n}) and returns some value that supports the "+" operation (e.g. an estimated adjacency matrix).}

\item{B}{An integer, number of pairs of subsamples to be drawn. Defaults to \code{50}.}

\item{parallel}{A logical that indicates whether \code{parallel::mclapply()} should be used for fitting. Otherwise, \code{lapply()} is used.}

\item{num_cores}{An integer, number of cores to be used if \code{parallel}; will be set to \code{parallel::detectCores() - 1} if \code{NULL}. Defaults to \code{NULL}.}
}
\value{
The sum of results from \code{fitting_func()} applied to \code{2*B} lists of sub-indices of \code{1:n}.
}
\description{
Applies a fit function repeatedly to subsamples drawn as complementary pairs (CPSS).
}
\details{
A complementary pair of sub-indices of \code{1:n} is a pair of disjoint subvectors \code{1:n} each with length \code{floor(n/2)}.
The function draws \code{B} such pairs, and apply \code{fitting_func()} to each of these \code{2*B} lists of sub-indices.
Finally, the sum of the \code{2*B} returned values/vectors/matrices from \code{fitting_func()} are returned.
Assuming \code{fitting_func} takes a list of indices and returns an adjacency matrix, each entry in \code{CPSS_fit(n, fitting_func, B)} returns the number of times that entry equals to \code{1} in the \code{2*B} estimated adjacency matrices.

Note: The user is expected to call \code{CPSS_fit()}, followed by \code{CPSS_path()}, and then followed by \code{CPSS_control()}.
}
\examples{
m <- 3; n <- 200; B <- 5
adj_mat <- ZiDAG::make_dag(m, mode = "chain")
d <- ZiDAG::gen_zero_dat(seed=1, gen_para="pms", adj_mat=adj_mat, n=n, gen_uniform_degree=1)
fitting_func <- function(indices) return (
    ZiDAG::ziGDS(V=d$V[indices,], Y=d$Y[indices,], parametrization="pms", verbose=FALSE,
    control=list("max_uniform_degree"=1L, "tol"=1e-8, "print_best_degree"=FALSE)))
freq_B <- ZiDAG::CPSS_fit(nrow(d$V), fitting_func, B=B, parallel=TRUE, num_cores=1)
}
