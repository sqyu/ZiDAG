% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zero_est_core.R
\name{grad_full_vec}
\alias{grad_full_vec}
\title{Gradient of log_dhurdle1d_abk() (with scalar v and y) with respect to a, b, k.}
\usage{
grad_full_vec(V, Y, A, B, k11, Vo, Yo, minus_Y = TRUE)
}
\arguments{
\item{V}{A logical vector, indicating if each entry in \code{Y} is non-zero, i.e. \code{V = (Y != 0)}.}

\item{Y}{A numerical vector of i.i.d. 1-d Hurdle random variables.}

\item{A}{A number or a vector of the same length \code{Y}, the \code{a} parameter(s). Assumed to be results from \code{sum_A_mat()} run on \code{Vo} and \code{Yo}.}

\item{B}{A number or a vector of the same length \code{Y}, the \code{b} parameter(s). Assumed to be results from \code{sum_B_mat()} run on \code{Vo} and \code{Yo}.}

\item{k11}{A number, the \code{k} parameter.}

\item{Vo}{A numerical vector of the same dimension as \code{Yo} indicating if each entry in \code{Yo} is non-zero, i.e. \code{Vo = (Yo != 0)}.}

\item{Yo}{A numerical vector, a sample for the parent nodes (regressors).}

\item{minus_Y}{A logical, argument as in \code{sum_B_mat()}.}
}
\description{
Gradient of \code{log_dhurdle1d_abk()} (with scalar \code{v} and \code{y}) with respect to \code{a}, \code{b}, \code{k}.
}
\details{
The derivative of \code{log_dhurdle_vec_abk(V[,1], Y[,1], A, B, k)} with respect to \code{aa}, \code{bb} and \code{k}, where \code{A=sum_A_mat(aa, V[,2:p], Y[,2:p])} and \code{B=sum_B_mat(bb, V[,2:p], Y[,2:p], minus_Y)}.
}
\examples{
set.seed(1)
n <- 100; p <- 10
V <- matrix(rbinom(n*p, 1, 0.8), nrow=n, ncol=p)
Y <- matrix(rnorm(n*p) * V, nrow=n, ncol=p)
aa <- rnorm(2*p-1)
bb <- rnorm(2*p-1)
k <- abs(rnorm(1))
grad_vec <- grad_full_vec(V[,1], Y[,1], sum_A_mat(aa, V[,2:p], Y[,2:p]),
   sum_B_mat(bb, V[,2:p], Y[,2:p], minus_Y=TRUE), k, V[,2:p], Y[,2:p], minus_Y=TRUE)
numer_grad <- numDeriv::grad(function(x){
   log_dhurdle_vec_abk(V[,1], Y[,1], sum_A_mat(x[1:(2*p-1)], V[,2:p], Y[,2:p]),
      sum_B_mat(x[(2*p):(4*p-2)], V[,2:p], Y[,2:p], minus_Y=TRUE), x[4*p-1])}, c(aa, bb, k))
max(abs(grad_vec - numer_grad))

grad_vec <- grad_full_vec(V[,1], Y[,1], sum_A_mat(aa, V[,2:p], Y[,2:p]),
   sum_B_mat(bb, V[,2:p], Y[,2:p], minus_Y=FALSE), k, V[,2:p], Y[,2:p], minus_Y=FALSE)
numer_grad <- numDeriv::grad(function(x){
   log_dhurdle_vec_abk(V[,1], Y[,1], sum_A_mat(x[1:(2*p-1)], V[,2:p], Y[,2:p]),
      sum_B_mat(x[(2*p):(4*p-2)], V[,2:p], Y[,2:p], minus_Y=FALSE), x[4*p-1])}, c(aa, bb, k))
max(abs(grad_vec - numer_grad))
}
